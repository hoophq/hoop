---
description: 
globs: 
---

## Project Structure and Development Approach

1. **Follow existing project structure**: Observe the organization of files in the `src/cljs/` directory and maintain consistent namespace conventions. Respect the established project structure when suggesting new components or features.

2. **Work in incremental stages**: Break down complex tasks into discrete, manageable steps. Each step should build upon the previous one and lead clearly to the next. For example, first define the data model, then create the UI components, and finally implement event handlers.

3. **Reference recent files**: Use recently updated files as templates for new work. Pay attention to naming conventions, code organization, and documentation patterns in these files to maintain consistency.

4. **Suggest atomic changes**: Focus on modifying one aspect of the codebase at a time. This approach helps maintain clarity and reduces the risk of introducing errors.

## Component Design and Styling

1. **Optimize Reagent components**: Create components that leverage Reagent's efficient rendering. Prefer using form-2 components when component state is needed, and form-1 for stateless components. Use React hooks via interop only when necessary.

2. **Integrate Radix UI primitives properly**: When implementing Radix UI components, ensure they're properly wrapped for ClojureScript usage. Use the appropriate Reagent adapters and ensure event handling follows ClojureScript conventions.

3. **Apply Tailwind CSS thoughtfully**: Use Tailwind utility classes for styling following the project's existing patterns. Avoid inline styles and maintain a consistent approach to responsive design using Tailwind's breakpoint classes.

4. **Create reusable components**: Identify opportunities for component reuse. Extract common UI patterns into dedicated components that accept appropriate parameters to control their behavior and appearance.

## State Management with re-frame

1. **Separate concerns in re-frame patterns**: Maintain clear separation between:
   - Events (mutations)
   - Subscriptions (queries)
   - Effects (side effects)
   - Coeffects (external data)

2. **Organize namespaces properly**: Follow the established namespace structure for different aspects of re-frame:
   - Events in `events.cljs`
   - Subscriptions in `subs.cljs`
   - Views in `views.cljs`

3. **Establish clear data flow**: Ensure unidirectional data flow from events through the app-db to subscriptions and finally to views. Avoid circular dependencies or direct manipulation of app-db outside of event handlers.

4. **Minimize subscription complexity**: Design subscriptions that are focused and reusable. Use subscription layering for derived data rather than complex calculations in views.

## Figma Integration and Visual Accuracy

1. **Reference Figma designs explicitly**: When implementing UI components, always refer to the specific Figma artboard or component being implemented. Use comments to link the code to its visual design reference.

2. **Map Figma components to code**: Establish clear relationships between Figma components and their code implementations. Document these relationships to facilitate future updates.

3. **Maintain design fidelity**: Ensure implementation matches the Figma designs precisely, including spacing, colors, typography, and responsive behavior. Use Tailwind's configuration to match the design system.

4. **Request missing design context**: When a Figma reference is incomplete or missing, ask for clarification rather than making assumptions about the intended design.

## Error Prevention and Performance Optimization

1. **Avoid common ClojureScript/Reagent pitfalls**: Watch for potential errors such as:
   - Improper destructuring in component arguments
   - Missing key props in sequences
   - Inefficient subscription usage leading to unnecessary re-renders
   - Improperly handling JavaScript interop

2. **Maintain re-frame best practices**: Verify that:
   - Event handlers are pure functions when possible
   - Side effects are managed through proper effect handlers
   - Subscriptions are efficiently composed

3. **Optimize rendering performance**: Follow practices that enhance application performance:
   - Use React's memo pattern through Reagent where appropriate
   - Separate stateful and presentational components
   - Avoid creating new functions inside render functions

4. **Validate data early**: Implement schema validation for important data structures using Spec or Malli to catch errors early.

## Testing and Documentation

1. **Document complex logic**: Add explanatory comments for non-obvious code. Document the "why" behind implementation choices, not just the "what."

2. **Provide usage examples**: Include examples of how to use new components or functions. Consider suggesting additions to a Storybook if the project uses one.

3. **Update documentation**: Suggest updates to project documentation when implementing significant changes or new features.

## Workflow Guidelines

1. **Make atomic commits**: Structure changes as a series of focused, atomic commits with clear descriptions of what was changed and why.

2. **Write comprehensive PR descriptions**: Include context, purpose, implementation approach, and testing strategy in pull request descriptions.

3. **Follow iterative development**: Build features incrementally, with each iteration being fully functional and testable.

4. **Document technical decisions**: Maintain a record of why specific technical approaches were chosen, especially when alternatives were considered.

## AI Assistance Behavior

1. **Ask clarifying questions**: When requirements are unclear or incomplete, ask specific questions rather than making assumptions.

2. **Request Figma context**: Always ask for Figma links or screenshots when implementing visual components if they haven't been provided.

3. **Identify potential issues**: Proactively point out potential problems or edge cases in proposed implementations.

4. **Provide reasoning**: Explain the rationale behind suggested approaches, especially when multiple options exist.

5. **Follow up on implementation**: Ask how implemented solutions are working and if they need refinement.

## Project-Specific Conventions

1. **Follow established naming patterns**: Use consistent naming for:
   - Event IDs (e.g., `:app/initialize`, `:user/update`)
   - Subscription IDs
   - Component names
   - File organization

2. **Respect data structure conventions**: Maintain consistency with existing data structures in the app-db and component props.

3. **Use approved dependencies**: Stick to the established libraries and avoid introducing new dependencies without explicit discussion.

4. **Adhere to coding style**: Follow the project's conventions for formatting, indentation, and code organization.
